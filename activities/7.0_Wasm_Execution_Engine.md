# Tên công việc: 7.0 - Tích hợp Wasm Runtime và Thực thi Job

- **Người thực hiện (Implemented by):** Gemini & Khánh
- **Liên quan đến Giai đoạn (Related to Phase):** 2 & 5

---

## 📝 Kế hoạch thực thi (Execution Plan)

*Phần này mô tả kế hoạch chi tiết sẽ được thực hiện. Với chuyên môn về WebAssembly, tôi sẽ trình bày các bước kỹ thuật cần thiết để xây dựng một trình thực thi an toàn và hiệu quả.*

**1. Mục tiêu (Goal):**
*   Nâng cấp `provider-cli` từ một daemon chỉ biết "nhận việc" thành một "công nhân" thực thụ. Mục tiêu là giúp daemon có khả năng tải về một job từ IPFS, đọc `manifest.json`, thực thi file WebAssembly (Wasm) tương ứng, và gửi trả kết quả một cách hoàn chỉnh.

**2. Lý do (Reason):**
*   Đây là bước hiện thực hóa phần "tính toán" (Compute) trong mô hình DePIN (Decentralized Physical Infrastructure Networks) của chúng ta. Nếu không có bước này, toàn bộ hệ thống chỉ là một chuỗi các giao dịch on-chain mà không tạo ra bất kỳ giá trị tính toán thực tế nào. Việc thực thi Wasm và trả về kết quả là luồng công việc cốt lõi của một Provider.

**3. Các bước thực hiện (Steps):**

*   **Bước 1: Thiết lập Môi trường & Dependencies**
    *   Chúng ta cần hai thư viện chính. Tôi sẽ thêm chúng vào `package.json`:
        1.  `kubo-rpc-client`: Thư viện client chính thức để giao tiếp với IPFS daemon đang chạy trên máy của Provider.
        2.  `@wasmer/sdk`: Một Wasm runtime mạnh mẽ, hỗ trợ đầy đủ chuẩn WASI, cho phép chúng ta chạy các module Wasm và kiểm soát chặt chẽ quyền truy cập hệ thống của chúng.
    *   *Thao tác: Chạy `npm install kubo-rpc-client @wasmer/sdk`.*

*   **Bước 2: Implement Hàm Tải Job từ IPFS (`downloadJobDirectory`)**
    *   Tạo một hàm helper `async function downloadJobDirectory(cid)` trong `provider-cli.ts`.
    *   Hàm này sẽ kết nối tới IPFS daemon cục bộ (mặc định là `http://127.0.0.1:5001`).
    *   Nó sẽ tạo một thư mục tạm duy nhất trên hệ thống file của Provider.
    *   Nó sẽ tải toàn bộ nội dung của thư mục tương ứng với `cid` từ IPFS vào thư mục tạm này.
    *   Hàm sẽ trả về đường dẫn đến thư mục tạm.

*   **Bước 3: Implement Hàm Thực thi Wasm (`executeWasmJob`)**
    *   Đây là bước quan trọng nhất. Tạo hàm `async function executeWasmJob(jobDirectoryPath)`.
    *   **Đọc Manifest:** Hàm sẽ đọc và parse file `manifest.json` từ `jobDirectoryPath` để lấy ra `executable` và `args`.
    *   **Khởi tạo Wasmer với WASI:** Chúng ta sẽ khởi tạo một instance Wasmer. Điểm mấu chốt ở đây là cấu hình **WASI (WebAssembly System Interface)**:
        *   Chúng ta sẽ "map" thư mục `jobDirectoryPath` trên máy thật vào thư mục gốc `/` ảo bên trong sandbox của Wasm.
        *   Điều này có nghĩa là file Wasm khi chạy sẽ thấy các file `input.json`, `script.wasm`... như thể chúng đang ở thư mục gốc. Nó **không thể** nhìn thấy bất kỳ file nào khác trên máy của Provider. Đây chính là cơ chế bảo mật cốt lõi.
    *   **Thực thi:** Chạy module Wasm với các `args` đã đọc từ manifest.
    *   **Logging:** Thu lại `stdout` và `stderr` từ tiến trình Wasm để ghi log, giúp cho việc gỡ lỗi.
    *   Hàm sẽ trả về đường dẫn đến file/folder kết quả (dựa trên `output_path` trong manifest).

*   **Bước 4 (Mới): Implement Hàm Xử lý và Tạo "Gói Kết quả"**
    *   Sau khi `executeWasmJob` chạy xong, tạo một thư mục tạm mới cho gói kết quả (ví dụ: `result_pkg`).
    *   Lưu `stdout` và `stderr` đã thu được vào các file `result_pkg/stdout.txt` và `result_pkg/stderr.txt`.
    *   Di chuyển/copy kết quả chính từ `outputPath` vào một thư mục con, ví dụ: `result_pkg/output/`.
    *   Tạo một hàm helper `async function uploadToIpfs(directoryPath)` để tải toàn bộ thư mục `result_pkg` này lên IPFS và trả về `resultCid`.

*   **Bước 5 (Cập nhật): Tích hợp Toàn bộ Luồng vào Vòng lặp `listen`**
    *   Trong file `provider-cli.ts`, sau khi một job được chấp nhận thành công:
    1.  Gọi `downloadJobDirectory()` để lấy dữ liệu job về thư mục tạm.
    2.  Gọi `executeWasmJob()` và nhận về một object chứa `outputPath`, `stdout`, `stderr`.
    3.  Tạo thư mục "Gói Kết quả" và điền các file `stdout.txt`, `stderr.txt`, và output chính vào đó.
    4.  Gọi `uploadToIpfs()` với đường dẫn của "Gói Kết quả" để nhận về `resultCid`.
    5.  Gọi `program.methods.submitResults(resultCid)` để báo cáo kết quả lên blockchain.
    6.  Thực hiện dọn dẹp cả thư mục job và thư mục kết quả tạm.

---

## 🚀 Quy trình thực hiện (Implementation Process)

1.  **Đề xuất Kế hoạch:** Tôi đã trình bày kế hoạch chi tiết, đã được cập nhật ở trên.
2.  **Chờ phê duyệt:** Tôi đang đợi bạn xác nhận đồng ý với kế hoạch này.
3.  **Thực thi:** Sau khi bạn đồng ý, tôi sẽ tiến hành implement các thay đổi theo từng bước đã vạch ra.
4.  **Xác minh (Build & Test):** Sau mỗi bước, chúng ta cần chạy thử `provider-cli` với một job mẫu (được tạo thủ công) để đảm bảo các hàm hoạt động đúng.
5.  **Hoàn tất:** Hoàn thành việc tích hợp toàn bộ luồng xử lý job vào vòng lặp `listen`.

---

## 📚 Ghi chú & Tài liệu tham khảo (Notes & References)

*   **Yêu cầu tiên quyết:** Provider phải cài đặt và chạy một IPFS daemon (Kubo) trên máy của họ.
*   **Tài liệu tham khảo:**
    *   Wasmer JS SDK: [https://www.npmjs.com/package/@wasmer/sdk](https://www.npmjs.com/package/@wasmer/sdk)
    *   Kubo RPC Client: [https://www.npmjs.com/package/kubo-rpc-client](https://www.npmjs.com/package/kubo-rpc-client)
    *   WASI (WebAssembly System Interface): [https://wasi.dev/](https://wasi.dev/)